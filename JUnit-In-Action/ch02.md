# 2장 JUnit 핵심 들여다보기

실수는 발견으로 들어서는 관문이다. -제임스 조이스(James Joyce)

Calculator

```java
public class Calculator {

    public double add(double number1, double number2){
        return number1 + number2;
    }
}
```

```java

/**
 * 2.1 JUnit의 핵심
 *
 */
public class CalculatorTest {

    /**
     * 각 테스트 메서드를 호출할 때 마다 테스트 클래스의 인스턴스를 새로 생성 한다.
     * 테스트 메서드들을 독립된 메모리 공간에서 실행시켜, 의도치 않은 부작용을 방지하기 위해서
     *
     * 각기 다른 테스트 클래스 인스턴스에서 실행되어서, 인스턴스 변수는 공유될 수 없다.
     *
     * 테스트 검증에는 assert 메서드를 자주 사용
     * assert 메서드들의 파라미터 순서 패턴 똑같음
     * 첫번째 파라미터-> 예상값 , 두번째  파라미터 -> 실제값
     *
     */
    @Test
    public void testAdd(){
        Calculator calculator = new Calculator();
        double result = calculator.add(1,1);
        assertEquals(2, result, 0);
    }
    /**
     * 에러 메시지도 무조건 함께 기입하는 습관을 들이자.
     * 머피의 법칙 처럼.
     * assert가 실패했을 때, 무엇이 잘못되었는지 사람이 읽고 이해할 수 있는 메시지를 작성
     */

    /**
     * JUnit assert 메서드 예시
     *
     * assertArrayEquals("message" , A, B) : 배열 A와 B가 일치함을 확인한다.
     * assertEquals("message" , A, B) : 객체 A와 B가 일치함을 확인한다. B를 파라미터로 A의 equals() 메서드를 호출한다.(A.equals(B)).
     * assertSame("message", A, B) : 객체 A와 B가 같은 객체임을 확인한다. assertEquals 메서드는 두 객체의 값이 같은가를 검사하는데 반해(equals 메서드 사용), assertSame 메서드는 두 객체가 동일한 , 즉 하나의 객체인가를 검사한다(==연산자 사용)
     * assertTrue("message", A) : 조건 A가 참(true)임을 확인한다.
     * assertNotNull("message", A) : 객체 A가 null이 아님을 확인한다.
     */

    /**
     * - 테스트 클래스 : 테스트 메서드들이 있는 클래스
     * - 테스트 러너 : 테스트 스위트 실행 엔진. 자신만의 러너를 제작하는 방법도 소개함.
     * - 테스트 스위트 : 테스트들의 집합,  여러개의 테스트 클래스를 동시에 실행할때 사용(객체) , 별도의 테스트 스위트가 정의되지 않으면 모든 테스트를 포함하는 테스트 스위트를 자동으로 만들어줌.
     *
     * 테스트 클래스와 러너 , 스위트의 동작방식을 이해 하는게 핵심
     */

    /**
     * JUnit 핵심 객체
     *
     * Assert : 테스트하려는 조건을 작성, 조건이 만족되면 아무일 없었다는 듯이 지나가고 만족되지 못하면 예외를 던짐
     * Test : @Test 애노테이션이 부여된 메서드, 하나의 테스트를 뜻함. 메서드를 포함하는 클래스의 인스턴스를 생성 , 애노테이션을 메서드를 찾아 호출
     * Test 클래스 : @Test 메서드를 포함한 클래스
     * Suite : 스위트, 여러 테스트 클래스를 하나로 묶는 수단
     * Runner : 테스트를 실행시킴, JUnit4 는 하위 호환성 유지 , JUnit 3 테스트 실행 가능
     *
     */
}

```

```java
/**
 * 2.2 파라미터화 테스트 실행하기
 *
 * 파라미터화 테스트 러너는 하나의 테스트를 여러 번 반복 실행하는 기능을 가지고 있다.
 * 단순 반복은 아니고, 테스트에 사용되는 각종 데이터를 파라미터로 뽑아서 매번 바꿔가며 테스트를 호출한다.
 */

@RunWith(Parameterized.class) // 테스트 클래스는 반드시 @RunWith 애노테이션을 부여 , 그 파라미터로는 Parameterized 클래스를 사용
public class ParameterizedTest {
    private double expected; // 테스트에 사용될 값을 인스턴스 변수로 선언
    private double valueOne;
    private double valueTwo;

    @Parameterized.Parameters // getTestParameters 메서드에 해당됨
    public static Collection<Integer[]> getTestParameters(){
        return Arrays.asList(new Integer[][]{
            {2, 1, 1}, // 예상값, 값 1, 값2
            {3, 2, 1}, // 예상값, 값1, 값2
            {4, 3, 1}, // 예상값, 값1, 값2
            {3, 1, 2},
        });
    }

    // 생성자가 정의되어 있음 파라미터를 받는 생성자들이 사용됨
    public ParameterizedTest(double expected, double valueOne, double valueTwo){
        this.expected = expected;
        this.valueOne = valueOne;
        this.valueTwo = valueTwo;
    }

    @Test // 테스트 메서드
    public void sum(){
        Calculator calc = new Calculator(); // Calculator 프로그램의 인스턴스를 생성
        assertEquals(expected, calc.add(valueOne, valueTwo), 0); // 앞의 파라미터들을 사용해서 결과를 단언
        /**
         * 테스트 반복횟수는 @Parameters 메서드가 반환하는 컬렉션 크기로 결정
         * 세번 호출한 것과 동일한 결과
         * sum : assertEquals(2, calculator.add(1, 1), 0);
         * sum : assertEquals(3, calculator.add(2, 1), 0);
         * sum : assertEquals(4, calculator.add(3, 1), 0);
         */
    }


    /**
     * JUnit 런타임의 작동 방식에 대해서
     *
     * 1. 정적 메서드인 getTestParameters를 호출 -> 컬렉션 객체 얻기
     * 2. 컬렉션의 저장된 배열의 수만큼 순환
     * [각 루프 안에서 벌어지는 일]
     * 3. 유일한 public 생성자 찾기 ( 만약 public 생성자가 두개 이상이면, AssertionError를 던짐)
     * 4. 찾은 생성자의 배열의 원소를 파라미터로 넣어 호출
     * 5. 첫째 배열{2, 1, 1}을 파라미터로 입력 파라미터 세 개짜리 생성자 호출
     * 6. 마지막으로 @Test 메서드 호출
     */

    /**
     * 파라미터화 테스트 러너의 차이는 동일한 테스트를 @Parameters 컬렉션의 원소 개수 만큼 실행하는 차이가 있다.
     */
}


```

## 스위트에 대해서

테스트 클래스가 하나가 아니라면 ? -> 테스트 스위트
스위트 : 테스트를 담는 그릇 , 여러 테스트를 묶어 한번에 실행할 때 사용
테스트러너가 스위트를 실행시키면, 전적으로 스위트가 테스트를 골라 실행한다.
사용자가 스위트를 따로 제공하지 않으면 테스트 러너가 자동으로 하나를 만든다.

@Test 메서드별로 테스트 클래스의 인스턴스 생성은 스위트 안에서 이루어짐
차례로 실행 시키되, 독립적으로 실행됨

```java
/**
 * 스위트의 스위트 만들기
 * 이것도 가능하다.
 * 여러 파일을 한꺼번에 나열한것으로 , 여러 테스트 스위트를 만들고, 최종적으로 마스터 스위트를 만드는 모습까지 보여줌
 */

public class TestCaseA {
    @Test
    public void testA1(){
        // 생략
    }
}

public class TestCaseB{
    @Test
    public void testB1(){
        // 생략
    }
}

@RunWith(value = Suite.class)
@Suite.SuiteClasses(value = {TestCaseA.class})
public class TestSuiteA{
}

@RunWith(value = Suite.class)
@Suite.SuiteClasses(value = {TestCaseB.class})
public class TestSuiteB{
}

@RunWith(value = Suite.class)
@Suite.SuiteClasses(value = {TestSuiteA.class, TestSuiteB.class})
public class MasterTestSuite{
}

/**
 * 실무에서는 TestSuiteA , TestSuiteB 도 두 개 이상의 테스트 클래스를 포함하는 것이 일반적임
 */
```

## JUnit 테스트 러너
테스트를 처음 작성하면서, 가능한 빠르고 쉽게 돌려보길 원하는 것은 당연하다.
개발 주기에 테스트 단계가 포함하도록 조정해야 한다.
코딩 - 수행 - 테스트 - 코딩 순서
테스트 주도 (test-first) 방식을 선호하면,
테스트 - 코드 - 수행 - 테스트 순서

#### 테스트 러너 종류
JUnit 3.8 전용 : 3.8 테스트 케이스 전용
JUnit 4 전용 : JUnit 4 스타일의 테스트 케이스를 실행
Parameterized : 같은 테스트 케이스를 다른 입력 값을 사용해 반복 수행
Suite : 복수의 테스트를 묶을 수 있는 집합 , 테스트 클래스 내의 모든 @Test 메서드를 찾아 실행하는 러너이기도 함

